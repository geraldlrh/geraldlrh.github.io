<!DOCTYPE html>
<html>
  <head>
    <title>clswp的前世今生</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-slide-content h1 { font-size: 3em; }
      .remark-slide-content h2 { font-size: 2em; }
      .remark-slide-content h3 { font-size: 1.6em; }
      .footnote {
        position: absolute;
        bottom: 3em;
      }
      a {
        text-decoration: none;
        color: #3baedf;
      }
      li p { line-height: 1.25em; }
      .red { color: #fa0000; }
      .bold {
        font-weight: bold;
      }
      .large { font-size: 2em; }
      code {
        background: #e7e8e2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      #slideshow .slide .content code {
        font-size: 0.8em;
      }
      #slideshow .slide .content pre code {
        font-size: 0.9em;
        padding: 15px;
      }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }
      /* Slide-specific styling */
      .define {
        display: block;
        background: #e7e8e2;
        border-radius: 5px;
        margin-left: 50px;
        padding: 20px 10px;
      }
      img {
        max-height: 500px;
        max-width: 800px;
      }
      .fl img{
        max-width: 390px;
        float: left;
      }
    </style>
  </head>
  <body>
    <textarea id="source">
name: inverse
layout: true
class: center, middle, inverse
---
name: normal
layout: true
class: top, left
---
template: inverse

# clswp 的前世今生
liurihui
2016-8-2

---
template: inverse

## 楔子

---

### 知乎的一个问题

[大公司里怎样开发和部署前端代码？](http://www.zhihu.com/question/20790576/answer/32602154)

--

一开始

![1](https://raw.githubusercontent.com/fouber/blog/master/assets/resource/01.png)

--

无需编译，本地预览

--

![2](https://raw.githubusercontent.com/fouber/blog/master/assets/resource/02.png)

简单粗暴！

---

### 后来

304，让浏览器使用本地缓存

![3](https://raw.githubusercontent.com/fouber/blog/master/assets/resource/03.png)

--

连304都干掉

![4](https://raw.githubusercontent.com/fouber/blog/master/assets/resource/04.png)

--

问题来了，.red[怎么更新？]

---

### 再后来...

修改资源路径，比如加个版本号？

![5](https://raw.githubusercontent.com/fouber/blog/master/assets/resource/05.png)

--

上线：

![6](https://raw.githubusercontent.com/fouber/blog/master/assets/resource/06.png)

---
### 版本号管理

![7](https://raw.githubusercontent.com/fouber/blog/master/assets/resource/07.png)

--

都更新了

---

### 引入MD5

![8](https://raw.githubusercontent.com/fouber/blog/master/assets/resource/08.png)

--

只更新有修改的文件，貌似已经完美了

---

### 页面和资源分开部署

![10](https://raw.githubusercontent.com/fouber/blog/master/assets/resource/10.png)

--

.red[先发布页面还是先发布静态资源？]

---

#### 先部署页面，再部署资源

在二者部署的时间间隔内，如果有用户访问页面，就会在新的页面结构中加载旧的资源，并且把这个旧版本的资源当做新版本缓存起来，其结果就是：用户访问到了一个样式错乱的页面，除非手动刷新，否则在资源缓存过期之前，页面会一直执行错误。

--

#### 先部署资源，再部署页面

在部署时间间隔之内，有旧版本资源本地缓存的用户访问网站，由于请求的页面是旧版本的，资源引用没有改变，浏览器将直接使用本地缓存，这种情况下页面展现正常；但没有本地缓存或者缓存过期的用户访问网站，就会出现旧版本页面加载新版本资源的情况，导致页面执行错误，但当页面完成部署，这部分用户再次访问页面又会恢复正常了。

---

### 非覆盖式发布

![11](https://raw.githubusercontent.com/fouber/blog/master/assets/resource/11.png)

先静态资源再页面

---

## 小结

1. 配置超长时间的本地缓存 —— 节省带宽，提高性能
2. 采用MD5作为缓存更新依据 —— 精确的缓存控制
3. 静态资源CDN部署 —— 优化网络请求
4. 资源发布路径实现非覆盖式发布 —— 平滑升级

---
template: inverse

## 前端工程

---

## 前端工程

- 模块化/组件化开发
- 资源加载、压缩、合并
- 代码规范、检查
- 脚手架等等

[前端工程浅谈](http://geraldlrh.github.io/get-start-to-frontend-engineering.html)

---
template: inverse

## mucfc-webpack

---

## 局部（npm run） vs 全局（clswp）

--

优点：
- 修改、升级成本低

--

缺点：
- 复用性差

---

## 命令

```bash
$ clswp

  Usage: clswp [options] [command]

  Commands:

    init|i               初始化新的项目
    page|p               创建新的页面
    comp|c               创建新的组件
    dev|d [options]      本地编译项目或页面，开发模式
    stl|sitl [options]   本地编译项目或页面，测试/联调模式
    prod|pr              打包项目或页面，生产模式
    st|sit               打包项目或页面，测试/联调模式
    sync|s               将已打包的文件发布到指定环境，使用之前请先打包！
    update|up            更新clswp的版本
    outdate|out          检查是否已更新到最新版本
    *                  

  Options:

    -h, --help     output usage information
    -V, --version  output the version number

``` 

---

## 结构

```bash
  clswp 
  ├── bin 
  │   └── clswp # 总入口
  ├── command # 单个命令入口
  │   ├── comp
  │   ├── dev
  │   ├── prod
  │   ├── ...
  │   └── outdate
  └── config # 默认配置
``` 

---

## 学习及调试

### node-dev
1. git clone 下来clswp包，安装依赖，全局安装`node-dev`

2. 启用本地的clswp来编译，修改`proj-demo/debug.sh`，指定clswp的路径和编译模式。运行 `sh debug.sh`

  ```bash
  #!/bin/bash

  node-dev /Users/liu/code/mucfc/clswp/bin/clswp d
  ```

3. 修改自定义配置，位于`proj-demo/module.config.js`或`proj-demo/wepack.config.js`，比如添加`vue-loader`等

4. `node-dev`会自动重启编译

---

## 学习及调试

### node-inspect(node-debug)

  ```bash
  #!/bin/bash

  node-debug --no-preload --hidden='node_modules/' /Users/liu/code/mucfc/clswp/bin/clswp d
  ```
添加debugger， 单步调试

---

## Tips

- 手动更新

--

- 不安装 `image-webpack`

---
template: inverse

## 未来

---

## 未来

- 整合工程化项目

--

- webpack2.0 [Tree-shaking](http://www.2ality.com/2015/12/webpack-tree-shaking.html)

--

- 性能优化

--

- 求issue, 求.red[pr]

---
template: inverse

## Q & A

    </textarea>
    <script src="./remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>